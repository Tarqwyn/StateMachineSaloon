var fs = require('fs'),
cheerio = require('cheerio'),
model = require('model'),
parse = require('css-parse');
 
function OrganiseCssTask() {

	/*------------------------------------------------------------------
		Variables
	------------------------------------------------------------------*/
	var taskFlow = [
		collateMediaQueriesInCss
	];
	var currentSubTask = 0;
	var cssFilePath;

	/*------------------------------------------------------------------
		Methods
	------------------------------------------------------------------*/
	function go() {

		cssFilePath = model.outputFolderPath + '/static/css/common.' + model.projectNumber + '.css';

		taskFlow[0]();

		/*---------------
			Strings
		---------------*/

		/*---------------
			Listeners
		---------------*/
		// model.eventEmitter.emitEvent(model.emitterEvents.ARTICLE_TASK_COMPLETE);

		console.log("TODO organise css task:");

	}
	this.go = go;

	function collateMediaQueriesInCss() {
		///////////////////////////
		fs.readFile(cssFilePath, 'utf8', function(err, cssStr) {
			var outputObj = parse(cssStr);

			var mediaQueries = [], everythingElse = [];
			var a, b, c, ruleLength = outputObj.stylesheet.rules.length;
			for (a = 0; a < ruleLength; a++) {
				var ruleObj = outputObj.stylesheet.rules[a];
				if (ruleObj.type === "media") {
					mediaQueries.push(ruleObj);
				}
				else {
					everythingElse.push(ruleObj);
				}
			}

			var mediaQueryLookup = {}, mediaQueryOutputArr = [];
			var queryLength = mediaQueries.length;
			for (a = 0; a < queryLength; a++) {
				
				var objKey = mediaQueries[a].media;

				if (!mediaQueryLookup[objKey]) {
					mediaQueryLookup[objKey] = mediaQueries[a].rules;
				}
				else {
					mediaQueryLookup[objKey] = mediaQueryLookup[objKey].concat(mediaQueries[a].rules);
				}
				mediaQueryOutputArr.push({
					title: objKey,
					data: mediaQueryLookup[objKey]
				});
			}

			var outputCssStr = "";

			var pretifyCss = true;

			var newLine = (pretifyCss) ? "\n" : " ";
			var tab = (pretifyCss) ? "\n  " : "";
			var tabNoNewLine = (pretifyCss) ? "\t" : "";
			var space = (pretifyCss) ? " " : "";
			var commaSeperator = "";

			var arrLength = everythingElse.length;
			for (a = 0; a < arrLength; a++) {
				var cssObj = everythingElse[a];
				if (cssObj.type === "rule") {
					var selectorLength = cssObj.selectors.length;
					for (b = 0; b < selectorLength; b++) {
						commaSeperator = "";
						if (b < (selectorLength - 1)) {
							if ((cssObj.selectors[b].indexOf(":") + 1) || (cssObj.selectors[b].indexOf(" ") + 1)) {
								commaSeperator = ",";
							}
						}
						outputCssStr += (cssObj.selectors[b] + commaSeperator + " ");
					}
					outputCssStr += "{";
					outputCssStr += tab;
					var declarationsLength = cssObj.declarations.length;
					for (b = 0; b < declarationsLength; b++) {
						outputCssStr += (cssObj.declarations[b].property + ":" + space + cssObj.declarations[b].value + ";");
						if (b < (declarationsLength - 1)) {
							outputCssStr += tab;
						}
					}
					outputCssStr += (newLine + "}");
					outputCssStr += newLine;
				}
			}

			outputCssStr += (newLine + "/* MediaQueries */" + newLine);

			arrLength = mediaQueryOutputArr.length;
			//mediaQueryOutputArr[a].title:string
			//mediaQueryOutputArr[a].data:Array
			for (a = 0; a < arrLength; a++) {
				outputCssStr += ("@media" + mediaQueryOutputArr[a].title + space + "{" + tab);
				
				///
				var queryArray = mediaQueryOutputArr[a].data;
				for (b = 0; b < queryArray.length; b++) {
					
					var mediaQuerySelectorRule = queryArray;
					if (mediaQuerySelectorRule[b].type === "rule") {
						for (c = 0; c < mediaQuerySelectorRule[b].selectors.length; c++) {

							commaSeperator = "";
							if (b < (mediaQuerySelectorRule[b].selectors.length - 1)) {
								if ((mediaQuerySelectorRule[b].selectors[c].indexOf(":") + 1) || (mediaQuerySelectorRule[b].selectors[c].indexOf(" ") + 1)) {
									commaSeperator = ",";
								}
							}
							outputCssStr += (mediaQuerySelectorRule[b].selectors[c] + commaSeperator + " ");

							// outputCssStr += (mediaQuerySelectorRule[b].selectors[c] + " ");
						}
						outputCssStr += ("{" + newLine + tabNoNewLine + tabNoNewLine);

						for (c = 0; c < mediaQuerySelectorRule[b].declarations.length; c++) {
							outputCssStr += (mediaQuerySelectorRule[b].declarations[c].property + ":" + space + mediaQuerySelectorRule[b].declarations[c].value + ";");
							outputCssStr += (newLine + tabNoNewLine);
							if (c < (mediaQuerySelectorRule[b].declarations.length - 1)) {
								outputCssStr += tabNoNewLine;
							}
						}

						outputCssStr += ("}" + newLine);
						if (b < (queryArray.length - 1)) {
							outputCssStr += tabNoNewLine;
						}
					}
				}
				///

				outputCssStr += "}";
				if (a < (arrLength - 1)) {
					outputCssStr += newLine;
				}
			}

			writeOutFile(cssFilePath, outputCssStr, subTaskComplete);

		});
		///////////////////////////
	}

	/*------------------------------------------------------------------
		UTILITIES
	------------------------------------------------------------------*/
	function subTaskComplete() {
		currentSubTask ++;
		if (currentSubTask < taskFlow.length) {
			taskFlow[currentSubTask]();
		}
		else {
			taskComplete();
		}
	}

	function taskComplete() {
		model.eventEmitter.emitEvent(model.emitterEvents.ARTICLE_TASK_COMPLETE);
	}

	function readModuleFile(path, callback) {
		try {
			var filename = require.resolve(path);
			fs.readFile(filename, 'utf8', callback);
		} catch (e) {
			callback(e);
		}
	}

	function writeOutFile(filePath, fileContents, callback) {
	fs.writeFile(filePath, fileContents, function(fileWriteErr) {
		if (fileWriteErr) {
			model.stateMachine.publishStateChange(model.appStates.ERROR_STATE, "ERROR: problem writing file: " + filePath);
		}
		else {
			callback();
		}
	});
}

}
 
module.exports = new OrganiseCssTask();