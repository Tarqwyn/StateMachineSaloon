var fs = require('fs'),
model = require('model'),
ncp = require('ncp'),
rimraf = require('rimraf');
 
function CopyInputIntoOutput() {

	/*------------------------------------------------------------------
		Variables
	------------------------------------------------------------------*/
	var $ = model.$, el;
	var errorMsgStr;
	var inputDir;
	var outputDir;

	/*------------------------------------------------------------------
		Methods
	------------------------------------------------------------------*/
	/**
	* dirObj:Object --- properties:
	*	input:String
	*	output:String
	*/
	function go(dirObj) {
		$ = $ || model.$;

		inputDir = dirObj.input;
		outputDir = dirObj.output;
		model.outputFolderPath = outputDir;
		
		var $el = $('.toolholder');
		$el.empty();

		//check to see if the output folder exists or not, if not create it!
		if (fs.existsSync(dirObj.output)) {
			//the folder already exists
			//check to see if there is stuff in the folder before carrying on
			var files = fs.readdirSync(dirObj.output);
			if (files) {
				//theres files in there already ... chuck a warning
				var titleStr = "ShortHand repurposing tool";
				var appTitle = $('.appTitle');
				appTitle.html(titleStr);

				$el.load("../html/screens/inputToOutputcopy.html", screenHtmlLoaded);
			}
			else {
				//the folders empty, everything is ok
				copyContents();
			}
		}
		else {
			//the folder doesn't exist, lets create it yo!
			fs.mkdir(dirObj.output, function(e) {
				copyContents();
			});
		}
	}
	this.go = go;

	function screenHtmlLoaded() {
		$('#okByMe').click(function() {
			deleteNonEmpydirectory(copyContents);
			$('#okByMe').unbind('click');
		}.bind(this)).bind(this);
		$('#woahThere').click(function() {
			model.stateMachine.publishStateChange(model.appStates.CHOOSE_OUTPUT_DIRECTORY);
		});
	}

	function deleteNonEmpydirectory(callback) {
		var deleteFolderRecursive = function(path) {
			if(fs.existsSync(path) ) {
				fs.readdirSync(path).forEach(function(file,index) {
					var curPath = path + "/" + file;
					if(fs.statSync(curPath).isDirectory()) { // recurse
						deleteFolderRecursive(curPath);
					} else { // delete file
						fs.unlinkSync(curPath);
						callback();
					}
				});
				fs.rmdirSync(path);
			}
		};
		deleteFolderRecursive(model.outputFolderPath);
	}

	function copyContents() {
		
		ncp(inputDir, outputDir, function (err) {
			if (err && err[0].errno !== 47) {
				//error number 47 is a warning that the output directory already exists
				return console.error("copy error: ", err);
			}
			else {
				model.stateMachine.publishStateChange(model.appStates.DISPLAY_CHANGE_OPTIONS);
			}
		});
	}

	function rmDir(dirPath) {
		var files;
		try {
			files = fs.readdirSync(dirPath);
		}
		catch(e) {
			return e;
		}
		if (files.length > 0) {
			for (var i = 0; i < files.length; i++) {
				var filePath = dirPath + '/' + files[i];
				if (fs.statSync(filePath).isFile()) {
					fs.unlinkSync(filePath);
				}
				else {
					rmDir(filePath);
				}
			}
		}
		fs.rmdirSync(dirPath);
	}

	/*------------------------------------------------------------------
		UTILITIES
	------------------------------------------------------------------*/

}
 
module.exports = new CopyInputIntoOutput();