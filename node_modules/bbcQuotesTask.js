var fs = require('fs'),
ncp = require('ncp'),
cheerio = require('cheerio'),
model;
 
function AddBbcQuotesTask() {

	/*------------------------------------------------------------------
		Variables
	------------------------------------------------------------------*/
	var taskFlow = [copyFonts, addQuotesCss, lookForQuotesHooks];
	var currentSubTask = 0;
	var projectName, indexHtmlPath;
	var $;
	var vidsToAdd = [];
	var cssFilePath;
	var fontNames = ["bbc_quote.eot", "bbc_quote.svg", "bbc_quote.ttf", "bbc_quote.woff"];
	var currentFontCopied = 0;

	/*------------------------------------------------------------------
		Methods
	------------------------------------------------------------------*/
	function go() {

		model = require('model');
		$ = $ || model.$;
		var $el = $('.toolholder');
		cssFilePath = model.outputFolderPath + '/static/build/css/common.min.css';

		taskFlow[0]();

	}
	this.go = go;

	function copyFonts() {
		copyFont();
	}

	function copyFont() {
		var footerCssPath = model.localAssetsPath + model.fontsPath + "/" + fontNames[currentFontCopied];
		var outputDir = model.outputFolderPath + "/static/fonts";
		
		//copy the istats lib into the new lib directory
		ncp(footerCssPath, outputDir + "/" + fontNames[currentFontCopied], function (err) {
			if (err) {
				return console.error("copy error: ", err);
			}
			currentFontCopied ++;
			if (currentFontCopied < fontNames.length) {
				copyFont();
			}
			else {
				subTaskComplete();
			}
		});
	}

	function addQuotesCss() {
		fs.readFile(cssFilePath, 'utf8', function(err, cssStr) {
			var bbcQuoteCssPath = model.localAssetsPath + model.cssPath + "/bbcQuoteCss.css";
			var bbcQuoteCssStr = fs.readFileSync(bbcQuoteCssPath, 'utf8');
			
			cssStr = cssStr + bbcQuoteCssStr;

			writeOutFile(cssFilePath, cssStr, subTaskComplete);
		});
	}

	function lookForQuotesHooks() {
		var indexPath = model.outputFolderPath + '/index.html';
		readModuleFile(indexPath, function (err, indexHtmlStr) {
			if (err) {
				console.log("err = ", err);
			}

			var regex = /{{#bbcQuote}}(.*?){{\/bbcQuote}}/gi;

			var foundMatches = indexHtmlStr.match(regex);

			if (foundMatches) {
				var a, arrLength = foundMatches.length;
				for (a = 0; a < arrLength; a++) {
					var quoteString = foundMatches[a].substring(13, foundMatches[a].length - 13);

					var replaceStr = foundMatches[a];

					var replaceMarkup =	"<div class='quoteHolder'>" +
											"<div>" +
												"<h1>Ó†Å</h1>" +
											"</div>" +
											"<p>" + quoteString + "</p>" +
										"</div>";

					indexHtmlStr = indexHtmlStr.strReplace(replaceStr, replaceMarkup);
				}

				writeOutFile(indexPath, indexHtmlStr, subTaskComplete);
				// writeOutFile(indexPath, indexHtmlStr, function() {});
			}

		});
	}

	function subTaskComplete() {
		currentSubTask ++;
		if (currentSubTask < taskFlow.length) {
			taskFlow[currentSubTask]();
		}
		else {
			taskComplete();
		}
	}

	function taskComplete() {
		model.eventEmitter.emitEvent(model.emitterEvents.ARTICLE_TASK_COMPLETE);
	}

	/*------------------------------------------------------------------
		UTILITIES
	------------------------------------------------------------------*/
	function readModuleFile(path, callback) {
		try {
			var filename = require.resolve(path);
			fs.readFile(filename, 'utf8', callback);
		} catch (e) {
			callback(e);
		}
	}

	function writeOutFile(filePath, fileContents, callback) {
	fs.writeFile(filePath, fileContents, function(fileWriteErr) {
		if (fileWriteErr) {
			model.stateMachine.publishStateChange(model.appStates.ERROR_STATE, "couldn't write file " + filePath + " :s");
		}
		else {
			callback();
		}
	});
}

}
 
module.exports = new AddBbcQuotesTask();